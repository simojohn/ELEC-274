.equ	JTAG_UART_BASE,	0x10001000
.equ	DATA_OFFSET,	0
.equ	STATUS_OFFSET,	4
.equ	WSPACE_MASK,	0xFFFF

.text

.global _start
.org 0x0000
_start:
main_loop:
	call 	GetChar
	call 	PrintChar
	br		main_loop

GetChar:
	subi	sp, sp, 4				# adjust stack and save r3 so we can use it
	stw		r3, 0(sp)
	movia	r3, JTAG_UART_BASE		# make r3 point to first memory-mapper I/O register
gc_loop:
	ldwio	r2, DATA_OFFSET(r3)		# read bits from data register
	andi	r4, r2, 0x8000			# check bit 15 for status
	beq		r4, r0, gc_loop			# if bit 15 is zero, loop again
	andi	r2, r2, 0xFF			# else, extract the lowest 8 bits
	ldw		r3, 0(sp)				# restore r3
	addi	sp, sp, 4				# fix stack
	ret								# return to calling subroutine

PrintChar:
	subi	sp, sp, 8				#adjust stack and save r3 and r4 so we can use them
	stw		r3, 4(sp)
	stw		r4, 0(sp)
	movia	r3, JTAG_UART_BASE		#make r4 point to first memory-mapper I/O register
pc_loop:
	ldwio	r4, STATUS_OFFSET(r3)	#read bits from status register
	andhi	r4, r4, WSPACE_MASK		#mask off lower bits to isolate upper bits
	beq		r4, r0, pc_loop			#if upper bits are zero, loop again
	stwio	r2, DATA_OFFSET(r3)		#else, write char to data register
	ldw		r3, 4(sp)				#restore r3 and r4
	ldw		r4, 0(sp)
	addi	sp, sp, 8				#fix stack
	ret								#return to calling subroutine
